import { afterEach, describe, it } from "@std/testing/bdd";
import { expect } from "@std/expect";
import { render } from "preact-render-to-string";
import { MarkdownConfigProvider } from "../context.tsx";
import { Markdown } from "../markdown.tsx";
import { MarkdownCacheProvider } from "../markdown-cache.tsx";

describe("Markdown", () => {
  describe("server rendering", () => {
    it("should render tabi-markdown marker", () => {
      const html = render(<Markdown># Hello</Markdown>);

      expect(html).toContain("<tabi-markdown>");
      expect(html).toContain("</tabi-markdown>");
    });

    it("should include content inside marker", () => {
      const html = render(<Markdown># Hello World</Markdown>);

      expect(html).toContain("# Hello World");
    });

    it("should escape HTML entities in content", () => {
      const html = render(<Markdown>{"<div>test</div>"}</Markdown>);

      expect(html).toContain("&lt;div&gt;test&lt;/div&gt;");
      expect(html).not.toContain("<div>test</div>");
    });

    it("should escape ampersands", () => {
      const html = render(<Markdown>Tom & Jerry</Markdown>);

      expect(html).toContain("Tom &amp; Jerry");
    });

    it("should escape quotes", () => {
      const html = render(<Markdown>Say "hello"</Markdown>);

      expect(html).toContain("Say &quot;hello&quot;");
    });

    it("should handle multiline content", () => {
      const content = `# Title

Paragraph text.

\`\`\`ts
const x = 1;
\`\`\``;
      const html = render(<Markdown>{content}</Markdown>);

      expect(html).toContain("# Title");
      expect(html).toContain("Paragraph text.");
      expect(html).toContain("const x = 1;");
    });

    it("should handle empty content", () => {
      const html = render(<Markdown />);

      expect(html).toContain("<tabi-markdown></tabi-markdown>");
    });

    it("should wrap marker in div element with data attribute", () => {
      const html = render(<Markdown>test</Markdown>);

      expect(html).toMatch(/^<div data-tabi-md="[^"]+">.*<\/div>$/);
    });
  });

  describe("client rendering", () => {
    afterEach(() => {
      // Restore server environment
      delete (globalThis as Record<string, unknown>).window;
    });

    it("should read content from cache context on client", () => {
      // Simulate client environment
      (globalThis as Record<string, unknown>).window = {};

      // The id generated by useId will be "P0-0" in test environment
      const cacheData = { "P0-0": "<p>preserved content</p>" };

      const html = render(
        <MarkdownCacheProvider initialData={cacheData}>
          <Markdown># Hello</Markdown>
        </MarkdownCacheProvider>,
      );

      expect(html).toContain("preserved content");
      expect(html).toContain("data-tabi-md");
      expect(html).not.toContain("tabi-markdown");
    });

    it("should render empty div when cache has no matching entry", () => {
      // Simulate client environment
      (globalThis as Record<string, unknown>).window = {};

      const html = render(
        <MarkdownCacheProvider initialData={{}}>
          <Markdown># Hello</Markdown>
        </MarkdownCacheProvider>,
      );

      // Falls back to empty content when cache entry doesn't exist
      expect(html).toMatch(/^<div data-tabi-md="[^"]+"><\/div>$/);
    });

    it("should render empty div when no cache provider", () => {
      // Simulate client environment without cache provider
      (globalThis as Record<string, unknown>).window = {};

      const html = render(<Markdown># Hello</Markdown>);

      // Falls back to empty content when no cache provider
      expect(html).toMatch(/^<div data-tabi-md="[^"]+"><\/div>$/);
    });
  });

  describe("wrapperClassName", () => {
    it("should apply wrapperClassName from context on server", () => {
      const html = render(
        <MarkdownConfigProvider config={{ wrapperClassName: "prose" }}>
          <Markdown># Hello</Markdown>
        </MarkdownConfigProvider>,
      );

      expect(html).toContain('class="prose"');
      expect(html).toMatch(/<div data-tabi-md="[^"]+" class="prose">/);
    });

    it("should apply multi-word wrapperClassName from context", () => {
      const html = render(
        <MarkdownConfigProvider
          config={{ wrapperClassName: "prose prose-lg dark:prose-invert" }}
        >
          <Markdown># Hello</Markdown>
        </MarkdownConfigProvider>,
      );

      expect(html).toContain('class="prose prose-lg dark:prose-invert"');
    });

    it("should not add class attribute when wrapperClassName is undefined", () => {
      const html = render(
        <MarkdownConfigProvider config={{}}>
          <Markdown># Hello</Markdown>
        </MarkdownConfigProvider>,
      );

      expect(html).not.toContain("class=");
    });

    it("should apply wrapperClassName on client", () => {
      // Simulate client environment
      (globalThis as Record<string, unknown>).window = {};

      const cacheData = { "P0-0": "<p>content</p>" };

      const html = render(
        <MarkdownConfigProvider config={{ wrapperClassName: "prose" }}>
          <MarkdownCacheProvider initialData={cacheData}>
            <Markdown># Hello</Markdown>
          </MarkdownCacheProvider>
        </MarkdownConfigProvider>,
      );

      expect(html).toContain('class="prose"');

      // Cleanup
      delete (globalThis as Record<string, unknown>).window;
    });
  });
});
